# 数据类型及用途
* string
有2中保存格式，int和sds\
sds又有两种保存格式，一种是只读的embstr，一种是raw，两者的边界在32-50字节，修改embstr会自动转为raw，embstr类似于直接存值，raw则是存了另一个引用\
应用场景：缓存对象、锁、简单计数\
redis锁的实现，主要是redis执行命令是单线程，因此是原子的\
* list
列表\
quicklist实现，3.2以前使用压缩列表和双向链表\
应用场景：没有消费组的消息队列、秒杀队列\
* set
无序且唯一集合，支持交集差集\
一般用整数集合及hash表保存数据，当元素全是整数且个数少于512时用整数集合\
应用场景：点赞、共同关注、抽奖\
* zset
有序且唯一集合\
与set相比不支持交集差集，但支持排序\
应用场景：排行榜、需要排名的点赞、需要排名的关注、姓名排序、电话号码排序\
* hash
key-value集合，与string相比，哈希可以一个键对应多个键值对\
一般用哈希表实现，哈希表是通过哈希函数进行分散，并通过单向链表解决哈希冲突，速度不够时可用二分树代替\
应用场景：购物车
* geo
保存经纬度\
直接使用zset的数据结构\
应用场景：滴滴打车\
* hperloglog
提供不精确的去重计数\
相比string和hash节省空间，但有0.81%的误差\
应用场景：百万计uv计数\
* stream
为消息队列提供的类型，支持消费组，支持消息持久化等\
应用场景：消息队列\
相比成熟的消息队列的主要问题：\
在AOF或主从转换时可能丢消息\
面对消息堆积对内存资源影响很大\
发布、订阅机制因为没有任何数据类型的实现，所以无法持久化\
发布订阅模式是发后即忘，如果有消费者重连，也不能消费之前的消息\
* bitmap
点阵图\
用二进制字节数组实现，每个位表示一个二值状态\
应用场景：连续签到\



# 缓存问题

## 缓存雪崩
大量缓存数据同一时间失效，导致大量请求直接访问到数据库\
解决方案：\
均匀设置缓存过期时间\
redis中没有数据时，加互斥锁保证只有一个线程在创建redis数据，减少对数据库访问\
设置后台线程更新缓存\
redis宕机时准备熔断机制，跳过对数据库访问，直接返回错误\

## 缓存击穿
在某个热点数据突然过期时，大量对该热点的请求访问到数据库\
解决方案：\
互斥锁\
热点数据过期前，设置后台线程更新缓存\

## 缓存穿透
用户访问既不在缓存中也不在数据库中的空数据\
解决方案：\
限制非法请求\
缓存空值或默认值\
使用布隆过滤器快速判断数据是否存在\



# 持久化
redis数据持久化有AOF及RDB两种方式\

## AOF
通过保存执行的命令记录数据库状态（不保存读命令）\

### AOF过程
执行命令时将命令写入AOF缓冲区\
经由写回策略将AOF缓冲区内容写入硬盘\

* AOF缓冲区
一个内存区域，避免命令执行写入命令记录时对同一硬盘文件占用导致的阻塞，也可避免直接写入文件导致的语法错误\
AOF缓冲区存在导致的问题：写入AOF不会直接写入文件，导致服务器宕机会导致缓冲区内容丢失\

### 写回策略
* always
每次写操作后都会将AOF缓冲区内容同步到硬盘，可靠性高\
缺点：性能低\
* everysec
每秒将对AOF缓冲区内容执行异步同步到硬盘\
* no
不自主执行同步，完全等待操作系统命令，性能好\
缺点：可靠性低\

### AOF重写
当硬盘中AOF文件过大，就会启动AOF重写，会删除多余的AOF命令，比如多次设置一个键值，只会保留最后一个\
使用子进程完成，因为父子进程内存共享，但彼此之间只读，线程之间内容共享但没有只读机制，需要添加锁，消耗额外性能\

#### AOF重写过程
新建AOF重写缓冲区，用于记录在重写过程中新增的命令\
重写原AOF文件\
将AOF重写缓冲区内容写入新文件\

## RDB
以二进制的快照形式保存数据库\
可以手动执行save或bgsave运行，或者在满足配置的相关要求的时候自动执行\

* SAVE与BGSAVE的区别，save会阻塞当前redis的所有运行，bgsave不会

### RDB配置
可以修改redis.conf的save选项进行配置\
一般设置多条策略\
```
# save sec change_times
save 30 5   #每30s执行一次，检测服务器修改次数是否距离上次执行已经达到5次，达到就执行save，否则执行次数的计数归0
```

实现方式:\
根据配置数量维护一个数组，保存一个计数，达到执行时间比较计数与配置值，无论执行成功与否都清零计数\

## AOF和RDB的对比

RDB文件以二进制存储，比AOF文件小\
RDB是快照形式，比AOF恢复更快\
AOF执行损耗性能更小，单次只保存该次的数据，RDB每次执行都会重写备份一次数据库，在数据库大时性能很差\
AOF的可靠性更高，RDB会损失最后一次快照之后的所有数据，AOF只损失AOF缓冲区还没有同步到硬盘的数据\