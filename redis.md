# 数据类型及用途
* string
有2中保存格式，int和sds\
sds又有两种保存格式，一种是只读的embstr，一种是raw，两者的边界在32-50字节，修改embstr会自动转为raw，embstr类似于直接存值，raw则是存了另一个引用\
应用场景：缓存对象、锁、简单计数\
redis锁的实现，主要是redis执行命令是单线程，因此是原子的\
* list
列表\
quicklist实现，3.2以前使用压缩列表和双向链表\
应用场景：没有消费组的消息队列、秒杀队列\
* set
无序且唯一集合，支持交集差集\
一般用整数集合及hash表保存数据，当元素全是整数且个数少于512时用整数集合\
应用场景：点赞、共同关注、抽奖\
* zset
有序且唯一集合\
与set相比不支持交集差集，但支持排序\
应用场景：排行榜、需要排名的点赞、需要排名的关注、姓名排序、电话号码排序\
* hash
key-value集合，与string相比，哈希可以一个键对应多个键值对\
一般用哈希表实现，哈希表是通过哈希函数进行分散，并通过单向链表解决哈希冲突，速度不够时可用二分树代替\
应用场景：购物车
* geo
保存经纬度\
直接使用zset的数据结构\
应用场景：滴滴打车\
* hperloglog
提供不精确的去重计数\
相比string和hash节省空间，但有0.81%的误差\
应用场景：百万计uv计数\
* stream
为消息队列提供的类型，支持消费组，支持消息持久化等\
应用场景：消息队列\
相比成熟的消息队列的主要问题：\
在AOF或主从转换时可能丢消息\
面对消息堆积对内存资源影响很大\
发布、订阅机制因为没有任何数据类型的实现，所以无法持久化\
发布订阅模式是发后即忘，如果有消费者重连，也不能消费之前的消息\
* bitmap
点阵图\
用二进制字节数组实现，每个位表示一个二值状态\
应用场景：连续签到\



# 缓存问题

## 缓存雪崩
大量缓存数据同一时间失效，导致大量请求直接访问到数据库\
解决方案：\
均匀设置缓存过期时间\
redis中没有数据时，加互斥锁保证只有一个线程在创建redis数据，减少对数据库访问\
设置后台线程更新缓存\
redis宕机时准备熔断机制，跳过对数据库访问，直接返回错误\

## 缓存击穿
在某个热点数据突然过期时，大量对该热点的请求访问到数据库\
解决方案：\
互斥锁\
热点数据过期前，设置后台线程更新缓存\

## 缓存穿透
用户访问既不在缓存中也不在数据库中的空数据\
解决方案：\
限制非法请求\
缓存空值或默认值\
使用布隆过滤器快速判断数据是否存在\
